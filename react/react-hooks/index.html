<!DOCTYPE HTML><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="description" content="Study hard, day day up!"><meta name="author" content="大西瓜"><meta name="generator" content="Hugo 0.66.0"><title>大西瓜🍉</title><link rel="stylesheet" href="/css/main.css"><link href="/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="icon"><!--[if lt IE 9]>
	<script src="js/ie/html5shiv.js"></script>
	<script src="js/ie/html5shiv.jsrespond.min.js"></script>
	<![endif]--></head><body><div id="wrapper"><header id="header" class="alt"><a href="/" class="logo"><strong>大西瓜</strong> <span>🍉 👶</span></a><nav><a href="#menu">菜单</a></nav></header><nav id="menu"><ul class="links"><li><a href="/">主页</a></li><li><a href="/stories">故事</a></li><li><a href="/javascripts">javascript</a></li><li><a href="/pages">页面展示总结</a></li><li><a href="/react">react</a></li><li><a href="/vue">vue</a></li><li><a href="/svg">svg</a></li><li><a href="/config">配置汇总</a></li></ul><ul class="actions vertical"><li><a href="/blogs" class="button special fit">开始吧</a></li><li><a href="/" class="button fit">Log In</a></li></ul></nav><div id="main" class="alt"><section id="one"><div class="inner"><header class="major"><h1></h1><span>Mon, 01 Jan 0001 00:00:00</span></header><h3 id="react-hooks-record">React Hooks Record</h3><blockquote><p>Hook 使用了Js的闭包机制</p></blockquote><h4 id="hook规则">Hook规则</h4><ol><li>只在最顶层使用 Hook</li><li>不要在普通的Javascript函数中调用Hook</li><li>useEffect 不会在服务端渲染时执行</li></ol><h4 id="useeffect">useEffect</h4><blockquote><p>等价于class模式的三个生命周期集合 componentWillUnMount, componentDidMount, componentDidUpdate</p></blockquote><ol><li><p>useEffect会在每次渲染<code>结束后</code>执行(在第一次渲染后以及每次更新后都会执行), 在执行当前effect的时候会对上一个effect进行清除</p></li><li><p>useEffect分无需清除的effect和需要清除的effect, 需要清除的effect需要返回一个函数, effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次</p></li><li><p>使用多个effect实现<code>关注点分离</code>, 需要的时候, 将不同的逻辑分离开</p></li><li><p>特定场景下设置需要依赖的props来选择性的执行effect</p></li><li><p><code>useEffect</code> 只是底层 API，未来业务接触到的是更多封装后的上层 API，比如 <code>useFetch</code> 或者 <code>useTheme</code>，它们会更好用。</p></li><li><p>总结一下需要用到副作用hook的场景</p><ul><li>DOM操作</li><li>Localstorage</li><li>fetch数据请求</li><li>定时器、计时器</li><li>&hellip;</li></ul></li></ol><blockquote><p>warning 未来版本，可能会在构建时自动添加第二个参数。</p></blockquote><h4 id="usereducer">useReducer</h4><blockquote><p>useEffect的兄弟函数 在useEffect无法解决的计时器问题时, 可以考虑useReducer函数, 将更新和动作解耦</p></blockquote><p>上代码:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">state</span>, <span style="color:#a6e22e">dispatch</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useReducer</span>(<span style="color:#a6e22e">reducer</span>, <span style="color:#a6e22e">initialState</span>);
<span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">count</span>, <span style="color:#a6e22e">step</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">state</span>;

<span style="color:#a6e22e">useEffect</span>(() =&gt; {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">id</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">setInterval</span>(() =&gt; {
    <span style="color:#a6e22e">dispatch</span>({ <span style="color:#a6e22e">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;tick&#34;</span> }); <span style="color:#75715e">// Instead of setCount(c =&gt; c + step);
</span><span style="color:#75715e"></span>  }, <span style="color:#ae81ff">1000</span>);
  <span style="color:#66d9ef">return</span> () =&gt; <span style="color:#a6e22e">clearInterval</span>(<span style="color:#a6e22e">id</span>);
}, [<span style="color:#a6e22e">dispatch</span>]);
</code></pre></div><h4 id="usecallback">useCallback</h4><p>一句话描述这个函数干的事情:</p><p>通过useCallback封装的函数, 可以直接作为依赖传入useEffect, useEffect只要关心取数函数是否变化, 而取数参数的变化在useCallback时处理, 依赖的参数变化时, useCallback会返回新的函数引用, 此时触发effect的执行, 再配合<a href="https://github.com/facebook/react/issues/14920"><code>eslint-plugin-react-hooks</code></a>插件的扫描, 就能做到 <code>有效依赖, 逻辑内聚, 易于开发者维护</code></p></div></section></div><footer id="footer"><div class="inner"><ul class="icons"><li><a href="https://www.twitter.com" class="icon alt fa-twitter" target="_blank"><span class="label">Twitter</span></a></li><li><a href="https://www.facebook.com" class="icon alt fa-facebook" target="_blank"><span class="label">Facebook</span></a></li><li><a href="https://www.instagram.com" class="icon alt fa-instagram" target="_blank"><span class="label">Instagram</span></a></li><li><a href="https://www.github.com" class="icon alt fa-github" target="_blank"><span class="label">GitHub</span></a></li><li><a href="https://www.linkedin.com" class="icon alt fa-linkedin" target="_blank"><span class="label">LinkedIn</span></a></li></ul><ul class="copyright"><li>&copy; Company Name</li><li>Design: <a href="https://www.html5up.net">HTML5 UP</a></li></ul></div></footer></div><script src="/js/jquery.min.js"></script><script src="/js/jquery.scrolly.min.js"></script><script src="/js/jquery.scrollex.min.js"></script><script src="/js/skel.min.js"></script><script src="/js/util.js"></script><script src="/js/vanilla-tilt.min.js"></script><script src="/js/main.js"></script></body></html>